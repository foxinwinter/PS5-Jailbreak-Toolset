#!/usr/bin/env python3
# main
# Copyright (c) 2026 foxinwinter
# Licensed under GPLv3. See Extra/Licenses/LICENSE

import argparse
import sys
import os
import importlib
import inspect
import platform
import hashlib

VERSION = "Alpha"

ROOT_DIR = os.path.dirname(os.path.abspath(__file__))
sys.path.insert(0, ROOT_DIR)

from Core.Exploits.Y2JB import Y2JB as Y2JBClass

EXPLOITS = {}
EXPLOIT_INFO = {}

TRUSTED_HASHES = {
    "Y2JB": [
        "8497b464c8a7d6bd2a332e30ffe42f6a1f117cb4200c44cce04084eb0b9f2383",
    ],
}


def scan_exploits():
    exploits_dir = os.path.join(ROOT_DIR, "Core", "Exploits")
    info_dir = os.path.join(exploits_dir, "info")

    for root, _, files in os.walk(exploits_dir):
        for filename in files:
            if filename.endswith(".py") and not filename.startswith("_"):
                module_name = filename[:-3]
                rel_path = os.path.relpath(os.path.join(root, filename), exploits_dir)
                rel_module = os.path.splitext(rel_path)[0].replace(os.sep, ".")
                file_path = os.path.join(root, filename)

                actual_hash = compute_sha256(file_path)
                trusted = TRUSTED_HASHES.get(module_name.upper(), [])

                if trusted and actual_hash not in trusted:
                    print(f"[Security] Skipping {module_name}: SHA256 not trusted ({actual_hash[:16]}...)")
                    continue

                if actual_hash:
                    print(f"[Security] Verified {module_name}: SHA256 ({actual_hash[:16]}...)")

                try:
                    module = importlib.import_module(f"Core.Exploits.{rel_module}")
                    for name, obj in inspect.getmembers(module):
                        if inspect.isclass(obj) and hasattr(obj, "run"):
                            if name == module_name or name.upper() == module_name.upper():
                                EXPLOITS[name.upper()] = obj
                                info = load_exploit_info(info_dir, module_name)
                                info["FilePath"] = file_path
                                EXPLOIT_INFO[name.upper()] = info
                except Exception as e:
                    print(f"Warning: Failed to load exploit module {module_name}: {e}")


def load_exploit_info(info_dir, exploit_name):
    info_subdir = os.path.join(info_dir, exploit_name)
    info_file = os.path.join(info_subdir, f"{exploit_name}.txt")
    intro_file = os.path.join(info_subdir, "intro.txt")
    info = {"About": "N/A", "Author": "N/A", "License": "N/A", "Intro": None, "SHA256": None, "FilePath": None}

    if os.path.exists(info_file):
        try:
            with open(info_file, "r") as f:
                content = f.read()
                for line in content.strip().split("\n"):
                    line = line.strip()
                    if line.startswith("About:"):
                        info["About"] = line.split(":", 1)[1].strip()
                    elif line.startswith("Author:"):
                        info["Author"] = line.split(":", 1)[1].strip()
                    elif line.startswith("License:"):
                        license_path = line.split(":", 1)[1].strip()
                        license_path = license_path.replace("RepoRoot", ROOT_DIR)
                        info["License"] = license_path
        except Exception:
            pass

    if os.path.exists(intro_file):
        try:
            with open(intro_file, "r") as f:
                info["Intro"] = f.read()
        except Exception:
            pass

    return info


def compute_sha256(file_path):
    sha256_hash = hashlib.sha256()
    try:
        with open(file_path, "rb") as f:
            for byte_block in iter(lambda: f.read(4096), b""):
                sha256_hash.update(byte_block)
        return sha256_hash.hexdigest()
    except Exception:
        return None


def validate_exploit(name):
    info = EXPLOIT_INFO.get(name)
    if not info:
        return False, "Exploit not found"

    trusted = TRUSTED_HASHES.get(name, [])
    if not trusted:
        return True, "No trusted hashes configured - skipping validation"

    file_path = info.get("FilePath")
    if not file_path or not os.path.exists(file_path):
        return False, "Exploit file not found"

    actual_hash = compute_sha256(file_path)

    if actual_hash not in trusted:
        return False, f"SHA256 mismatch! Not in trusted hashes."

    return True, "SHA256 validated"


def cmd_list(args):
    print("\nAvailable Exploits:")
    print(f"{'Name':<20} {'Author':<20} {'About'}")
    print("-" * 70)
    for name, info in EXPLOIT_INFO.items():
        about = info.get("About", "N/A")
        if len(about) > 25:
            about = about[:22] + "..."
        author = info.get("Author", "N/A")
        if len(author) > 18:
            author = author[:15] + "..."
        print(f"{name:<20} {author:<20} {about}")
    print()


def cmd_info(args):
    name = args.exploit.upper()
    if name not in EXPLOIT_INFO:
        print(f"Error: Unknown exploit '{args.exploit}'")
        print(f"Available exploits: {', '.join(EXPLOITS.keys())}")
        sys.exit(1)

    info = EXPLOIT_INFO[name]
    print(f"\n=== {name} ===")
    print(f"About:    {info.get('About', 'N/A')}")
    print(f"Author:   {info.get('Author', 'N/A')}")
    print(f"License:  {info.get('License', 'N/A')}")
    print()


def cmd_run(args):
    name = args.exploit.upper()
    if name not in EXPLOITS:
        print(f"Error: Unknown exploit '{args.exploit}'")
        print(f"Available exploits: {', '.join(EXPLOITS.keys())}")
        sys.exit(1)

    valid, message = validate_exploit(name)
    print(f"[Security] {message}")
    if not valid:
        print(f"Error: Cannot run exploit - {message}")
        sys.exit(1)

    exploit = EXPLOITS[name]()
    try:
        exploit.run(config_override=args.config)
    except KeyboardInterrupt:
        print("\nInterrupted by user.")
        sys.exit(130)


def cmd_doctor(args):
    print("\n=== PS5 Jailbreak Toolset Doctor ===\n")

    errors = []
    warnings = []

    print(f"Python version: {platform.python_version()}")
    if sys.version_info < (3, 8):
        errors.append("Python 3.8+ required")
    else:
        print("[OK] Python version")

    required_dirs = [
        ("Core/Exploits", os.path.join(ROOT_DIR, "Core", "Exploits")),
        ("Core/Exploits/info", os.path.join(ROOT_DIR, "Core", "Exploits", "info")),
        ("payloads", os.path.join(ROOT_DIR, "payloads")),
        ("Tools", os.path.join(ROOT_DIR, "Tools")),
    ]

    for name, path in required_dirs:
        if os.path.isdir(path):
            print(f"[OK] {name}")
        else:
            errors.append(f"Missing directory: {name}")

    payload_paths = [
        os.path.join(ROOT_DIR, "payloads", "Y2JB", "setlogserver.js"),
        os.path.join(ROOT_DIR, "payloads", "Main", "PS5_Heuristic.js"),
        os.path.join(ROOT_DIR, "payloads", "Y2JB", "lapse.js"),
    ]

    for path in payload_paths:
        rel_path = os.path.relpath(path, ROOT_DIR)
        if os.path.exists(path):
            print(f"[OK] {rel_path}")
        else:
            warnings.append(f"Missing payload: {rel_path}")

    info_dir = os.path.join(ROOT_DIR, "Core", "Exploits", "info")
    if os.path.isdir(info_dir):
        info_files = [f for f in os.listdir(info_dir) if f.endswith(".txt")]
        print(f"[OK] Info directory ({len(info_files)} info files)")
    else:
        errors.append("Missing info directory")

    print()
    if errors:
        print("ERRORS:")
        for e in errors:
            print(f"  [ERROR] {e}")
    if warnings:
        print("WARNINGS:")
        for w in warnings:
            print(f"  [WARN] {w}")
    if not errors and not warnings:
        print("All checks passed!")
    print()


def main():
    scan_exploits()

    parser = argparse.ArgumentParser(description="PS5 Jailbreak Toolset")
    parser.add_argument("--version", action="version", version=f"%(prog)s {VERSION}")

    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    list_parser = subparsers.add_parser("list", help="List available exploits")

    info_parser = subparsers.add_parser("info", help="Show exploit info")
    info_parser.add_argument("exploit", help="Exploit name")

    run_parser = subparsers.add_parser("run", help="Run an exploit")
    run_parser.add_argument("exploit", help="Exploit name")
    run_parser.add_argument(
        "--config", action="store_true", help="Force prompt for PS5 configuration"
    )

    doctor_parser = subparsers.add_parser("doctor", help="Run environment diagnostics")

    args = parser.parse_args()

    if args.command == "list":
        cmd_list(args)
    elif args.command == "info":
        cmd_info(args)
    elif args.command == "run":
        cmd_run(args)
    elif args.command == "doctor":
        cmd_doctor(args)
    else:
        parser.print_help()


if __name__ == "__main__":
    main()
